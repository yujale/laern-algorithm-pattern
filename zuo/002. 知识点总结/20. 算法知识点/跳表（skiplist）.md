# 跳表（skiplist）

#跳表 #SkipList 

---
1）结构上根本和搜索二叉树无关

2）利用随机概率分布来使得高层索引可以无视数据规律，做到整体性能优良

3）思想是所有有序表中最先进的

4）结构简单就是多级单链表


---
![[Pasted image 20201218163207.png]]


不是BST, 用跳表实现有序表: 好实现, 思想先进  
为什么说思想先进?  
有点类似快排, 虽然随机出来一个数, 状况不定, 
但长期期望很低


跳表一开始第一个节点, 认为是系统最小值
 也有一个需要排序的key, 不过它是空的null
跳表最左侧的节点认为是弃而不用的
认为以后增加的所有key都比空大
用最左边null标记最小值的key
一开始只有一条往外指的指针

这个最左侧Node可以往外指的指针的条数, 需要可以扩充
设计成一个ArrayList, 在里头add一个null, 相当于
多了一条往外指的指针
有多条往外指的指针, List

完全凭运气决定一个节点有多少层, 最底层一定有所有数据
 任何节点一定至少有一层, 再此基础之上, 以50%的概率投色子
 
 

找的方式
从最高层开始, 越过一个节点, 底层跳过了很多
==>有高层到底层建立了索引关系

永远是高层走到不能再往右, 往下走
  再从下一层走到不能再往右, 再往下走
等同于一整颗大树走了一条路径下来
高层的节点一旦越过一个, 底层的节点就越过一大批, 


为什么最终能够收敛到logN?    
和输入状况没有关系, 因为任何数据都在扔色子, 
与输入的数据是什么无关, 完全凭运气做决定高层节点
到低层节点的数量分配
当数据量N很大的时候, 就不需要规定好哪个节点在第几层
只要这种机制保证了每一层节点减少一半
索引的数量就是逐渐递减的, 而且和输入数据没有关系
随机决定层数
索引数量就会减一半,减一半, 变成一种好的索引


可以完成有序表的所有功能

面试场上会真的让你手写跳表
 美团, 微软, airbnb
可能让你写某一段: 比如删除的时候怎么做



