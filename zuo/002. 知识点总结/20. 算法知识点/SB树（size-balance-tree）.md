# SB树（size-balance-tree）

#SB树

---
1）让每一个叔叔节点为头的数，节点个数都不少于其任何一个侄子节点  
2）也是从底层被影响节点开始向上做路径每个节点检查  
3）与AVL树非常像，也是四种违规类型：LL、RR、LR、RL  
4）与AVL树非常像，核心点是：  
- LL（做一次右旋）、RR（做一次左旋）  
- LR和RL（利用旋转让底层那个上到顶部）  

5）与AVL树不同的是，每轮经过调整后，谁的孩子发生变化了，谁就再查  

![[Pasted image 20201217221036.png]]


![[Pasted image 20201217162517.png]]

任何一个X节点, 满足SB树定义, 他左树跟右树节点数 数量关系
如果超过两倍,最多也就是两倍+1的水平
不可能再悬殊了

用叔叔跟侄子节点的数量关系来约束:
我左树跟右树的关系,即便相差了一些节点, 也不会特别悬殊, 最多也就达到2倍+1
不可能再大了

如果你能近乎保证一个树左右两边节点数差不多, 你就能说你的高度为logN

如果我能保证我的一个节点左右两树节点数目规模不会差到两倍+1以上, 基本上它的
树的高度也是logN水平


- [[SB树代码]]

## SB树在使用时候的改进

1）删除时候可以不用检查

2）就把平衡性的调整放在插入的时候

3）因为这种只要变就递归的特性，别的树没有

4）可以在节点上封装别的数据项，来增加功能



### 为什么比赛同学都拿SB树改写有序表?  
SB树比AVL快
因为SB的平衡性模糊
既能够保证平衡, 又不是那么精确的平衡
而AVL要严格平衡性, 比SB树扰动大
同时也因为是SB树的有趣的递归行为

高手在修改的时候, 他在一个节点删除时候不做平衡性调整,
即使越删越不平衡, 一律把平衡时机放在add时候
如果已经删掉很多了, 怎么能在某一次add的时候把整体都调平衡呢?   
-->有递归, 如果它不平衡的话, 它会帮我递归完成的, 
为什么这个结构重要, 它删除的时候不加平衡性的调整, 可以加
但是没有必要, 统一把平衡的时机放在add的时候, 虽然有可能会出现某些峰值, 
导致它可能不是logN, 但是均摊下来, 一定非常快

### 递归和迭代哪个更优?
任何递归行为都可以改成迭代, 
迭代更优
递归函数在系统上执行的时候, 
准备一个函数实际比较长, 常数项比较大, 
能够改成迭代的话, 最好改成迭代
但是递归清楚一些

