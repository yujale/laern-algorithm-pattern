# Morris遍历

---

一种遍历二叉树的方式，并且时间复杂度O(N)，额外空间复杂度O(1)  
 
通过利用原树中大量空闲指针的方式，达到节省空间的目的  


## Morris遍历细节

假设来到当前节点cur，开始时cur来到头节点位置  
1）如果cur没有左孩子，cur向右移动(cur = cur.right)  
2）如果cur有左孩子，找到左子树上最右的节点mostRight：  
	a. 如果mostRight的右指针指向空，让其指向cur，然后cur向左移动(cur = cur.left)  
	b. 如果mostRight的右指针指向cur，让其指向null，然后cur向右移动(cur = cur.right)  
3）cur为空时遍历停止  

- [[Morris遍历代码]]
- [[Morris实现前序遍历]]
- [[Morris实现中序遍历]]
- [[Morris实现后序遍历]] : 比较难

## Morris遍历实质

建立一种机制：

>对于没有左子树的节点只到达一次，  
对于有左子树的节点会到达两次   
morris遍历时间复杂度依然是O(N)  

- [[二叉树的最小深度]]  Morris遍历实现  
- [[判断二叉树是不是平衡二叉树]]  Morris遍历实现  

## Morris遍历总结

总结:
什么时候知道一个题目的最优解是Morris遍历
跟把解题流程定义有关

当你的算法求解过程, 你来到一个节点X时候, 需要你左树右树给你信息, 你需要做整合
如果解题方法是这个流程,没有办法做Morris遍历
==> 因为你需要左树, 右树给你一个答案, 空间一定不是O(1)
        因为左树的答案需要缓存, 等右树答案收集好以后才能够使用
        所以使用二叉树的递归套路解决
如果求解过程发现, 我并不需要右树的答案, 我的答案是递推的
我左树收集完答案以后再也不需要了, 就可以使用Morris遍历修改

搜索二叉树问题
如果流程定义为: 把我左树最大值跟右树最小值拿出来, 看左树是不是BST, 右树是不是BST
我自己看看能不能俩起来, 跟当前节点比较判断是不是BST
  需要很强的左右两侧收集信息这个流程-->无法使用Morris遍历
如果换一种思路, X只要在中序遍历中, 保证它一直递增,
  用完左树信息了, 并不需要保存这个信息, 单独一个变量可以把这个递推关系继承下去, 可以使用
Morris遍历

有些题必须要收集完全部信息才能解决-->无法使用Morris遍历
有些题通过分析发现这些信息可以往下递推, 并不需要所有信息都留着->可以用Morris遍历

想出一个比较容易的题解后, 用Morris遍历去套, 看看信息能不能传递, 如果能传递就可以修改

### Morris遍历常数项的问题

调用函数f()的常数项其实比较大
 准备调用一个函数, 在系统中准备它的运行环境, 常数项是比较大的
 比Morris这种Node = Node.right 要慢
 看着Morris遍历常数项比较大, 不能说递归的常数项不大
 递归调用的常数项其实很大的
 
 
