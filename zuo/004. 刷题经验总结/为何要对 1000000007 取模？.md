# 为何要对 1000000007 取模？

---


1000000007 这个数字是10bit位的最小质数，上面的代码并没有问题，只是数字太大溢出了，需要将计算结果 % 1000000007才能保证得出的结果在int 范围中



```java
private static int fib(int n) {

    if (n == 0) {
        return 0;
    }
    int[] arr = new int[n + 1];
    arr[1] = 1;
    return fib2(n, arr);
}

private static int fib2(int n, int[] arr) {

    if (n < 2) {
        return arr[n];
    }

    if (arr[n] > 0) {
        return arr[n];
    }
    arr[n] = (fib2(n - 1, arr) + fib2(n - 2, arr)) % 1000000007;
    return arr[n];
}
```

---

- 1000000007是一个质数。
- int32位的最大值为2147483647，所以对于int32位来说1000000007足够大。
- int64位的最大值为2^63-1，对于1000000007来说它的平方不会在int64中溢出。
- 在大数相乘的时候，因为(a∗b)%c=((a%c)∗(b%c))%c，所以相乘时两边都对1000000007取模，再保存在int64里面不会溢出。


---
模一个大数和模一个质数可以减少冲突。

比如说如果所有的结果都是偶数…你模6就只可能出现0, 2, 4这三种情况…但模5还是可以出现2, 4, 1, 3这四(4=5-1)种情况的…
hash表如果是用取模的方法也要模一个大质数来减少冲突，出题人也会这样来 希望减少你“蒙对“的概率。

而模1000000007又有一个很好的特点，就是相加不爆int，相乘不爆long long。

https://www.zhihu.com/question/26127900/answer/32253465

---


在模素数p的情况下a\*n（a非p的倍数）的循环节长为p,这是减少冲突的一个原因。另一方面模素数p的环是无零因子环,也就是说两个非p倍数的数相乘再模p不会是零（如果是0的话,在多个数连乘的情况下会大大增加冲突概率）。还有就是模素数所成的环还是个域,因而允许“除法”操作（乘以乘法逆元）,模非素数就没有这个性质。
一般来说x的选取只要10^x＋7保证比初始输入数据的范围大就可以了。比如有些数据范围小的题为了避免用long long而把模数设定为10007。至于为什么要用10^x＋7,大概是因为这种patten多为素数而又比较好记吧。

https://www.zhihu.com/question/26127900/answer/32261019