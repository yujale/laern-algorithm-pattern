# 记忆化搜索跟经典动态规划

---
你用傻缓存/记忆化搜索的方法, 和 改成严格表结构的方法, 整体肯定是比暴力递归方法好, 而且好的多  
记忆化搜索是你暴力的所有过程给画个表出来, 只不过记忆化搜索这些表不关心先后依赖关系, 你没算就直接去算, 你算过了就直接从表里拿东西返回

而严格表结构的动态规划是 我严格的整理好依赖关系, 从这张表简单位置填到复杂位置, 也就是说, 它比记忆化搜索, 进一步梳理了依赖关系, 从简单位置通过这个依赖关系算出复杂位置, 进而求出所有表的过程

记忆化搜索就是你没算过就去干递归, 你算过了就直接从表里拿东西返回
严格表结构就是从简单到复杂, 我严格规定好了先算哪个, 后算哪个

它们俩的时间复杂度:  
如果没有枚举行为, 这张表有多大, 你的复杂度就是多少,  暴力的两个分支就是: 2^N, 三个分支就是 : 3^N, 四个分支就是: 4^N, 但是记忆化搜索和严格表结构我们表有多大就算这么多格子, 因为一个格子就依赖有限的位置, 你把所有格子都推完, 这事就结束了

所以: 如果单独一个格子, 没有枚举行为(就是没有for循环), 它只依赖有限几个位置, 记忆化搜索和严格表结构的答案同样的好
如果有枚举行为, 那你就需要搞出严格表结构之后, 继续优化
建立好空间感之后, 你的枚举行为才能够想办法用临近位置把它代替了
比如[[面值数组组成面值的方法数-张数不限]]

## 记忆化搜索

记忆化搜索不依赖任何东西, 就是一个傻缓存, 它的时间复杂度只和组合的命中率有关, 
比如题目: [[打怪兽需要花的最小钱数]] 为例:  
能力越大, 越参差不齐, 组合的种类越多, 它可能命中率就很低了
而钱数在很窄的一个范围内, 哪怕这个范围内都有组合, 因为钱数的范围很窄, 它还是命中率很大
100个怪兽, 能力范围 0~10^6  
有没有这100个怪兽, 任意的组合能力值都不一样,  
有可能!  
拿怪兽的编号, 跟能力累加和做记忆化搜索,命中率很低
如果贿赂怪兽的钱数, 要么1, 要么2, 所有怪兽都贿赂才200元,   
用200元的维度去枚举, 大量命中


## 记忆化搜索跟经典动态规划的区别

> 如果决策过程中, 没有枚举行为
  任何一个状态, 只依赖有限的几个子状态, 二者复杂度无区别 
  所以, 笔试中改出记忆化搜索方法就可以了, 为了省时间  
  如果表中, 某一个位置有枚举行为, 要去改经典DP
   因为有可能写出经典动态规划方案之后, 能找到一个优化, 可以把状态转移继续做化简
   使得枚举行为变得更简洁, 有省掉枚举行为的可能性   
如果在暴力递归中, 算一个具体状态, 不是for循环的枚举, 
   背包问题, 机器人问题, 俩人取扑克问题, 数字转字符串问题, 都是有限若干个子状态
 没有必要把记忆化搜索改成经典动态规划, 因为二者时间复杂度一致, 
区别在于, 经典DP只是把结构化的东西做精细划分了, 从简单推到复杂
而记忆化搜索方法, 不关心, 就是没算过的我就去算, 如果算过了,就在缓存里拿值
 它只是没有组织好, 但是他们调用, 使用子状态, 连子状态的规模, 大小全是一样大, 所以二者等效
 
![[Pasted image 20201123191043.png]]


## 经典动态规划的样子 
如果能做出一张精确的位置依赖动态规划表
 每个格子从左往右, 从上往下,或者自己规定一个非常严格的顺序
从简单状态推到复杂状态


## 记忆化搜索是否改为经典动态规划

如果位置依赖是非常精确的,改起来比较容易就去改, 如果感觉位置依赖不是很明确,那就不改,记忆化
搜索的办法就可以了
怎么知道改到记忆化搜索就可以,不会有更好的方法?
你在推具体一个状态时,如果它就是有限几个位置依赖, 你改不改, 时间复杂度都不会有变化
 严格位置依赖有限几个位置, 记忆化搜索也是依赖有限几个位置 它俩其实是等效的
迫切需要改成严格位置依赖的情况:
  比如某道题, 位置依赖有多个, 而且有枚举行为, 这时候最好改, 因为改成严格位置依赖以后, 可以继续优化, 把这个枚举行为
  已经知道严格位置依赖,就可以得到它的状态转移方程, 在转移方程看看,这种遍历的枚举行为是不是能够被临近位置的一些值代替
  
  - [[二维数组最大递增链的长度]]  
  本题: a位置依赖上下左右 abcd位置,  要先求abcd的值吗? 不行, 因为b位置有可能反过来依赖a
 , 既然如此, 位置依赖顺序比较混乱, 就不把它做成严格位置依赖动态规划, 直接改成从顶到底的动态规划就结束了, 本质上没有区别
 
 
 如果没有枚举行为, 记忆化就行了  
为什么要搞出严格位置依赖的动态规划?  
如果有枚举行为, 我需要关心位置依赖, 我才去推  
 不过需要注意, 不是所有的枚举行为都能优化的,   如果你怎么都观察不出来, 那就可能没有 
有些时候,枚举行为是省不掉的, 它就是没有办法被邻近位置代表  你就只能硬去枚举  
如果能优化, 复杂度就直接减少一阶 直接就决定了你在笔试,面试中能不能通过的问题了

如果位置依赖特别复杂, 就不改严格动态规划, 用傻缓存就行了, 比如[[象棋问题-马只走K步跳到指定位置的方法数]]

