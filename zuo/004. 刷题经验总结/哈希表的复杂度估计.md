# 哈希表的复杂度估计

---

## [[哈希表增删改查在使用时可以认为是O(1)]]


哈希表怎么找一个key的记录在哪儿? 
过程就是:  
key自己通过hash函数算出一个hashcode, 然后模上内部的一个数, 去到具体的一个桶里面,
桶里面依次往下找, 找到一个key, 找到了, 把它的记录返回, 有value,无value的都是一样的.


![[Pasted image 20201224200601.png]]

如果我们忽略样本大小, 它就是O(1)的, 
但是你这个key是怎么通过hash函数算出hashcode的?  
一定是遍历它, 所以当我单样本这个key的长度不可忽略的时候, 假设是K, 那么哈希表的复杂度就是O(K)

比如给定一个字符串数组, 请找出一个重复的字符串返回  

每到一个字符串先检查在不在, 不在放入hash表, 如果在就返回, 如果字符串数组长度为N,
我们说这个算法的复杂度是O(N), 因为我们认为把单个字符串放入哈希表以及查找它是O(1)
但是实际上, 如果你的字符串长度非常大, 或者说它不可忽略,有一个长度K的话, 它就不是O(1)的了, 而是O(N\*K), 这个K必不可少

怎么确认两个字符串一样不一样?  
一般认为是O(1)的方法, 但它是吗? 不是!
你怎么知道两个两个字符串一样不一样, 你得遍历完这两个字符串才行

一般情况下的单样本比对我们认为是O(1)的, 当我的样本长度不可忽略的时候 , 你就不能认为它是O(1)的了, 最简单的就是两个字符串比较一样不一样, 它是一个O(K)的

关键就在于看你需不需要考虑单样本大小
你就拿两个数值来说, 我一个整数和另外一个整数比较大小, 是O(1)吗?
其实它比较了32bit, 如果我是k位的呢, 比较两个整数就是O(K)的

目的就是 你到底讨论到什么样的精度上, 我们来搞这个复杂度
有的时候可以忽略, 约定俗成, 大部分以经验来决定, 比较两个整数我就认为是O(1)的, 
你要较真它的位数是K, 比较两个整数就是O(K)的, 它确实是这样

如果它就是想要告诉你, 它的长度K是不可忽略的一个量, 那你就不能认为O(K)跟O(1)是等同的

[[两个字符串的最短的变换路径]] 就属于不可忽略, 因为它的字符串长度确实会影响它的性能, 而且很影响

```java
	public static int minCost1(String s1, String s2) {
		List<String> s2Subs = new ArrayList<>();
		process(s2.toCharArray(), 0, "", s2Subs);
		s2Subs.sort(new LenComp());
		for (String str : s2Subs) {
			if (s1.indexOf(str) != -1) { // indexOf底层和KMP算法代价几乎一样，也可以用KMP代替
				return s2.length() - str.length();
			}
		}
		return s2.length();
	}
```


