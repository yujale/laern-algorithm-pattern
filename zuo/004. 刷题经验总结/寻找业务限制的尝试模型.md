# 寻找业务限制的尝试模型

#寻找业务限制的尝试模型 

---

业务限制模型  以 [[丢棋子问题]]为例
发现给你两个可变参数, 一个剩的楼层, 一个剩的棋子  
两个可变参数, 我看我能不能试出来  
硬写了一个递归, 很自然的硬憋这个递归  

业务限制指的是:  
当我设计可变参数的时候, 充分考虑到它的业务限制  
有些业务限制是变成过滤条件, 在代码中以分支的形式来表现它,   
它不会体现在可变参数上,   
业务限制模型指的是:  
当我猜递归时候, 我的可变参数都要深入去搞题目本身所透露给我的题意

如果你发现参数不够, 你去补那个参数, 其实就是把业务的某种限制给抽象化出来
如果你返回值不够, 你去补返回值, 就是你列可能性过程中, 简单的返回值没有办法支持你的可能性计算, 那也是业务带给你的, 
所有的东西都来自你对业务的挖掘能力, 这种尝试模型就是业务限制模型

设计的可变参数不能直观的得到变化范围, 比如说[[多样本位置全对应的尝试模型]], 两个参数就是下标我明确知道它的变化范围, [[范围上的尝试模型]]我明确知道L,R都是下标, 而且左下半区没有用, 只用求对角线跟右上半区就可以了, 我明确知道它的变化范围, [[从左往右的尝试模型]]中的[[背包能装下最多的价值|背包问题]], 背包大小不超过多少容量, 我明确的知道bag不可能超过, 我明确知道它的变化范围, 当一个参数, 我没有办法, 很明确的知道它变化范围的时候, 这个时候, 我就要人为的想限制, 来把free([[喝咖啡洗咖啡杯问题]] )的大小估计出来, free取得的最大值是什么?  就是所有杯子都去洗, 冲到的最大的free, 它不可能超过. 也就是一句话: ==限制不够, 业务来凑==

非常关键的技巧:    
从暴力递归到动态规划的步骤:    
1.分析可变参数, 弄出表的大小, 如果这一步你弄不出表的大小, 一定是有一个可变参数的范围你不好估计, 你就按照它能够冲到的最大程度来估计, 
你写的递归尝试, 如果一个参数的可变范围你不知道, 就假设最差情况去算它, 看能冲多大    
2.再填DP表的时候, 有一个很重要的点, 你一定要关心哪些位置是你不需要填的, 比如说范围的尝试, 为什么左下半区你不需要填, 因为如果是真实的一个从L...R的范围的话, 左下半区一定不会被我的递归调到, 所以我不填它们, [[喝咖啡洗咖啡杯问题]]  的这道题 也一样, 如果我已经告诉你了, 洗20杯咖啡, 最疯的情况下, 咖啡杯的机器到100的时间点出来, 当你遇到第5杯, 假设100点的时候洗咖啡机才能让你用这个问题 不会在递归里出现, 就是超过100绝对不会被你用到, 你越界是因为啥?  你正常不管到哪一杯咖啡, 没有任何一个时刻, 这个洗咖啡的机器它空余居然在100以外, 如果你在决策中居然有越界了, 啥情况? 说明就目前为止你要做的这个决策, 所用的这个状态, 一定不会被你递归调到, 这个时候, 不填它. 它本质就和我们在范围上尝试L>R的时候, 不需要填, 一码事.
如果你实在改不出严格动态依赖的话, 就傻缓存


[[喝咖啡洗咖啡杯问题]]  
>int bestTime(int[ ] drinks, int wash, int air, int index, int free)  
> drinks 所有杯子可以开始洗的时间  
wash 单杯洗干净的时间（串行）  
air 挥发干净的时间(并行)  
free 洗的机器什么时候可用    
drinks[index.....]都变干净，最早的结束时间（返回）  
> free 怎么估计变化范围? 
> free取得的最大值是什么?  就是所有杯子都去洗, 冲到的最大的free, 它不可能超过
> 两个技巧:  
一个是 可变参数模型估计不出来, 拿业务本身最差情况估, 还有的情况是拿平凡解估, 两种方式   
第二个技巧点是 因为是严格表结构的东西, 它不一定你的递归都能够调到, 
这个时候一定要关心哪些位置是你不需要的, 不需要的位置不用填



[[丢棋子问题]]  



[[蛇走的轨迹问题]]
>非常标准的业务限制模型, 业务要怎么走, 它会怎么选, 题目告诉的清清楚楚
>你登上一个格子有三个方向, 那就尝试去就行
>暴力尝试就是: 业务逻辑抽象成递归表达
>其中的所有决策都是业务带给你的, 所以本题目是业务限制模型
