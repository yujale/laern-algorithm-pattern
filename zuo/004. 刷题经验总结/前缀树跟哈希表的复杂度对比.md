# 前缀树跟哈希表的复杂度对比

---

## Hash表

Hash表增删改查都是O(1):
 前提条件: 忽略单样本大小
 
 

哈希表加入一个额很长的字符串, 不能认为是O(1), 应该为 O(K)
 k 为字符串的长度
 hash表加入时, 要把字符串遍历一遍, 算出一个hash值, 才知道
 其在hash表里如何去组织
 
 Hash表在加东西, 如果认为单样本大小无足轻重, 复杂度可以认为是O(1)
 如果, 单样本本身长度不可以忽略, Hash表增删改查的复杂度是O(K)
  k: 单样本的平均长度
  
  如果是加入对象地址, 就是O(1), 因为对象地址很短
  比如自己实现的类型, 是把对象内存地址加入
  
  
  字符串类型的数组加入哈希表的代价:
 每来一个字符串,  需要遍历字符串 算出hash值才知道怎么在hash表里存储
 如果单样本大小不可以忽略, 那么把这些字符串放入hash表
  总代价: O(M), 总M字符数量
  因为每个字符串都要遍历才能加入hash表
  
  
  
  把某一个字符串类型数组已经加入hash表,  如果这时有一个新出现的字符串想要确定它在原来的字符数组中有几个?
  
  Hash表可以完成这个功能, 代价: 自己的长度不可以忽略, 查到你的记录代价O(K), K你的长度
  Hash表不支持查找有多少字符串是以指定字符串为前缀的
  
  这部分功能没有前缀树强大
  
  ## 前缀树
  
 把所有字符串加入前缀树的代价 也是 O(M), M: 所有的字符数
  
  查询一个字符串出现了几次代价  O(K), K是字符串的长度
  查询之前出现了多少个字符串以指定的字符串为前缀 O(K), K是字符串的长度