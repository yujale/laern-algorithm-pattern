# 根据具体输入数据状况看菜下饭的题目


---


[[问字符串s2最少删除多少字符可以成为s1的子串]]  
>如果s2很短, 生成s2的所有子序列, 看哪一个子序列是s1的子串(KMP), 例子:
 如果s2 长度10, 子序列是7, 就说明需要删掉3个字符 
 s2, M很小, 2^M不大, 乘以N之后也超不过10^8
 如果M很大, 求出S1所有的子串跟S2求编辑距离
  编辑的时候, 假设只有删除行为
  
  
[[两个字符串的最短的变换路径]]
>实际出现的题目中  
O(N^2 \* K) 还是 O (K^2)更大, 看菜下饭  
怎么求邻居表最快, 要根据实际的数据状况, 看菜下饭

[[返回数组中，有多少个独立的域]]


[[打怪兽需要花的最小钱数]]
>dp[i][j]: 0号怪兽一路通关到i号怪兽, 严格花够j元能得到的最大能力
不能完成记-1  
适用于钱数sum不是特别大, 能力大不大无所谓  
把能力long类型, 能力大小不决定表本身规模
 
 
 [[非负数组子序列中累加和%m的最大值]]  
 >存在看菜下饭  
如果你发现, 单个值给的比较大, sum就比较大, 就不选第一种方法   
如果发现m很大, 大的离谱, 而每个位置的值不是很大, 就选第一种方法   
如果M, sum很大, N不大, 第三种方法   

 >第三种方法:  
数组长度N, 把前一半定义为arrLeft, 后一半arrRight  
暴力方法, 求所有子序列的累加和  
假设有一个表list, 装着N/2的所有数字每一个子序列的累加和, 把所有累加和%/m加工出list\`  
对于右侧的arrRight也同样处理, 加工处理表叫list\`\`  
想凑出所有的累加和 模%m 最接近的, 答案有3个部分:  
1)子序列可能来自 arr 左侧,  
2)也可能来自 arr右侧,  
3)子序列有一部分来自 arr 左侧, 有一部分来自 arr right

>本题实际考法  
 数据状况有问题, 就是让你用第三种解法
 每个位置的值-->10^8  
N: 20个数, M-->10^12  
直接堵死, 第一种跟第二种方法  
如果用暴力2^20 超过10^8也不行  
就意味着一定让你想出分治的方法, 左侧分10个, 右侧分10个, 这样2^10不超过10^8    
分治的方法获胜, 根据N很小这个特点


[[使用单词表拼接长字符串的方法数]]
>使用前缀树加速  
>所有字符串的所有字符数量K, 建前缀树 复杂度O(K) + 
>后序动态规划的O(N^2)过程   
>如果后序非常多, 那么O(K) 会很大   
>如果, 候选不多, 但是字符串很长, 就用前缀树加速的方法   
>看菜下饭, 如果K很大就不大好了