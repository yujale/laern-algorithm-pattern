# 桶排序、排序总结


---

## 前缀树
1）单个字符串中，字符从前到后的加到一棵多叉树上  
2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）  
3）所有样本都这样添加，如果没有路就新建，如有路就复用  
4）沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1  

可以完成前缀相关的查询   

### 例子
设计一种结构。用户可以：
```html
1）void insert(String str)            添加某个字符串，可以重复添加，每次算1个
2）int search(String str)             查询某个字符串在结构中还有几个
3) void delete(String str)           删掉某个字符串，可以重复删除，每次算1个
4）int prefixNumber(String str)       查询有多少个字符串，是以str做前缀的
```

### 前缀树路的实现方式

题目1: [[固定数组实现前缀树]]

题目2: [[哈希表实现前缀树]]

[拓展:]
目前节点只是封装了p值跟e值, 可以封装别的更丰富的信息来解决某些问题
如果一些题带有前缀查询特征, 前缀树就可以通过每个节点增加更多信息支持本题目快速解决


Ps：我们实际来一把，对数器帮你找到bug的展示


## 不基于比较的排序
桶排序思想下的排序：计数排序 & 基数排序 

1)桶排序思想下的排序都是不基于比较的排序

2)时间复杂度为O(N)，额外空间负载度O(M)

3)应用范围有限，需要样本的数据状况满足桶的划分 

### 计数排序和基数排序
- 题目3: [[计数排序]]
- 题目4: [[基数排序代码]]

1）一般来讲，计数排序要求，样本是整数，且范围比较窄

2）一般来讲，基数排序要求，样本是10进制的正整数

一旦要求稍有升级，改写代价增加是显而易见的

## 排序算法的稳定性
稳定性是指同样大小的样本再排序之后不会改变相对次序

对基础类型来说，稳定性毫无意义

对非基础类型来说，稳定性有重要意义

有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的

## 排序算法总结

|       |时间复杂度 | 额外空间复杂度       | 稳定性|
| ----  | ----  | ----  | ----  |
|选择排序  |      O(N^2)      |    O(1)    |    无 |
|冒泡排序  |      O(N^2)      |    O(1)    |    有 |
|插入排序  |      O(N^2)      |    O(1)    |    有 |
|归并排序  |      O(N* logN)   |    O(N)    |    有 |
|随机快排  |      O(N* logN)   |    O(logN) |    无 |
|堆排序    |      O(N* logN)   |    O(1)    |    无 |
|               |                         |               |         |
|计数排序  |      O(N)        |    O(M)    |    有 |
|基数排序  |      O(N)        |    O(N)    |    有 |

1）不基于比较的排序，对样本数据有严格要求，不易改写  
2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用  
3）基于比较的排序，时间复杂度的极限是O($N*logN$)  
4）时间复杂度O($N*logN$)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存  在的。  
5）为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并  