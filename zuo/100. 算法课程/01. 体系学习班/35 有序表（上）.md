# 有序表（上）

---

## [[搜索二叉树]]

经典的BST是没有重复值的
任何一个节点为头的数, 左边的值都比头要小, 右边的数都比这个头要大
制药有一个节点破坏这个性质,就不是搜索二叉树


搜索二叉树一定要说明以什么标准来排序

经典的搜索二叉树，树上没有重复的用来排序的key值

如果有重复节点的需求，可以在一个节点内部增加数据项


## 搜索二叉树查询key（查询某个key存在还是不存在）


1）如果当前节点的value=key，返回true  
2）如果当前节点的value<key，当前节点向左移动  
3）如果当前节点的value>key，当前节点向右移动  
4）如果当前节点变成null，返回false  


## 搜索二叉树插入新的key

和查询过程一样，但当前节点滑到空的时候，就插入在这里

## 搜索二叉树删除key

0）先找到key所在的节点  
1）如果该节点没有左孩子、没有右孩子，直接删除即可  
2）如果该节点有左孩子、没有右孩子，直接用左孩子顶替该节点  
3）如果该节点没有左孩子、有右孩子，直接用右孩子顶替该节点  
4）如果该节点有左孩子、有右孩子，用该节点后继节点顶替该节点  


## 搜索二叉树特别不讲究

1）基础的搜索二叉树，添加、删除时候不照顾平衡性

2）数据状况很差时，性能就很差


给搜索二叉树引入两个动作：左旋、右旋


## AVL树、SB树、红黑树的共性


1）都是搜索二叉树

2）插入、删除、查询（一切查询）搜索二叉树怎么做，这些结构都这么做

3）使用调整的基本动作都只有左旋、右旋

4）插入、删除时，从最底层被影响到的节点开始，对往上路径的节点做平衡性检查

5）因为只对一条向上路径的每个节点做O(1)的检查和调整，所以可以做到O(logN)



## AVL树、SB树、红黑树的不同

1）平衡性的约束不同

AVL树最严格、SB树稍宽松、红黑树最宽松

2）插入、删除和搜索二叉树一样，但是额外，做各自的平衡性调整。各自的平衡性调整所使用的动作都是左旋或者右旋

## [[AVL树]] 

1）最严格的平衡性，任何节点左树高度和右树高度差不超过1
![[Pasted image 20201217185417.png]]
2）往上沿途检查每个节点时，都去检查四种违规情况：LL、RR、LR、RL

3）不同情况虽然看起来复杂，但是核心点是：
- LL（做一次右旋）、RR（做一次左旋）
- LR和RL（利用旋转让底层那个上到顶部）

