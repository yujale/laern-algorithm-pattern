# SB树、跳表、红黑树

#SB树 #跳表 #SkipList #红黑树

## 有序表
有序表TreeMap
HashMap增删改查 O(1)
Treemap O(logN) 底层是平衡搜索二叉树
使用Treemap必须保证key是可以排序的

有序表是一种规范, 它是接口名
 key: 有序组织
 增删改查: O(logN)
任何一个数据结构满足这些, 都是有序表
 AVL, SB树, 红黑树 都可以实现有序表, 性能指标几乎无差别
 跳表也是


## [[AVL树]]
任意头结点, 左树跟右树高度差小于2, 最严格的平衡性


- [[AVL树、SB树、红黑树的共性与不同]]

### 红黑树
1)每个节点不是红就是黑  
2)头结点是黑, 叶节点是黑  
3)红节点的子一定是黑节点 ==> 两个红不能相邻  
4)从任何节点到他的叶节点, 所有黑节点数量一样多  

最长的链: 黑红交替
最短的链: 全黑的
从任何节点到他的叶节点, 所有黑节点数量一样多
==>
结论: 长链的长度和短链的长度不可能大到一倍往上
最多就是两倍关系
红黑树用非常复杂的定义, 实际上背后指向的本质是想做到:
每一个节点往下的链, 它的长度不要到两倍以上的水平

红黑概念是红黑树自己规定的概念


## [[SB树（size-balance-tree）]]
任何一个叔叔节点拥有的节点数, 不少于他自己的任何一个侄子节点

用叔叔跟侄子节点的数量关系来约束:
我左树跟右树的关系,即便相差了一些节点, 也不会特别悬殊, 最多也就达到2倍+1
不可能再大了

如果你能近乎保证一个树左右两边节点数差不多, 你就能说你的高度为logN

如果我能保证我的一个节点左右两树节点数目规模不会差到两倍+1以上, 基本上它的
树的高度也是logN水平

