# 并查集结构和图相关的算法

#并查集 #图 #BFS  #DFS   
#最小生成树算法 #Kruskal #Prim #Dijkstra算法  
#拓扑排序   

---

## [[并查集]]

1. 有若干个样本a、b、c、d…类型假设是V  
2. 在并查集中一开始认为每个样本都在单独的集合里  
3. 用户可以在任何时候调用如下两个方法  ：  
       boolean isSameSet(V x, V y) : 查询样本x和样本y是否属于一个集合  
       void union(V x, V y) : 把x和y各自所在集合的所有样本合并成一个集合  
4. isSameSet和union方法的代价越低越好  

 
1）每个节点都有一条往上指的指针  
2）节点a往上找到的头节点，叫做a所在集合的代表节点  
3）查询x和y是否属于同一个集合，就是看看找到的代表节点是不是一个  
4）把x和y各自所在集合的所有点合并成一个集合，只需要小集合的代表点挂在大集合的代表点的下方即可  



### 并查集的优化

1）节点往上找代表点的过程，把沿途的链变成扁平的

2）小集合挂在大集合的下面

3）如果方法调用很频繁，那么单次调用的代价为O(1)，两个方法都如此

### 并查集的应用
连通性的问题

解决两大块区域的合并问题

常用在图等领域中

- [[真实的用户数量]]

## 图

1）由点的集合和边的集合构成

2）虽然存在有向图和无向图的概念，但实际上都可以用有向图来表达

3）边上可能带有权值

### 图结构的表达
1）邻接表法

2）邻接矩阵法

3）除此之外还有其他众多的方式
### 图的面试题如何搞定

图的算法都不算难，只不过coding的代价比较高

1）先用自己最熟练的方式，实现图结构的表达

2）在自己熟悉的结构上，实现所有常用的图算法作为模板

3）把面试题提供的图结构转化为自己熟悉的图结构，再调用模板或改写即可

### 图的宽度优先&深度优先遍历

#### [[宽度优先遍历]]
1，利用队列实现  
2，从源节点开始依次按照宽度进队列，然后弹出  
3，每弹出一个点，把该节点所有没有进过队列的邻接点放入队列  
4，直到队列变空  

#### [[深度优先遍历]]
1，利用栈实现  
2，从源节点开始把节点按照深度放入栈，然后弹出  
3，每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈  
4，直到栈变空   

### [[图的拓扑排序算法]]
1）在图中找到所有入度为0的点输出  
2）把所有入度为0的点在图中删掉，继续找入度为0的点输出，周而复始  
3）图的所有点都被删除后，依次输出的顺序就是拓扑排序  

要求：有向图且其中没有环  
应用：事件安排、编译顺序  

### [[最小生成树算法之Kruskal]]

1）总是从权值最小的边开始考虑，依次考察权值依次变大的边  
2）当前的边要么进入最小生成树的集合，要么丢弃  
3）如果当前的边进入最小生成树的集合中不会形成环，就要当前边  
4）如果当前的边进入最小生成树的集合中会形成环，就不要当前边  
5）考察完所有边之后，最小生成树的集合也得到了    

### [[最小生成树算法之Prim]]
1）可以从任意节点出发来寻找最小生成树  
2）某个点加入到被选取的点中后，解锁这个点出发的所有新的边  
3）在所有解锁的边中选最小的边，然后看看这个边会不会形成环  
4）如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3）  
5）如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2）  
6）当所有点都被选取，最小生成树就得到了  

### [[Dijkstra算法]]
1）Dijkstra算法必须指定一个源点   
2）生成一个源点到各个点的最小距离表，一开始只有一条记录，即原点到自己的最小距离为0，源点到其他所有点的最小距离都为正无穷大  
3）从距离表中拿出没拿过记录里的最小记录，通过这个点发出的边，更新源点到各个点的最小距离表，不断重复这一步  
4）源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了  


---
## 本课题目
- 题目1: [[并查集代码]]
- 题目2: [[图的拓扑排序算法]]
- 题目3: [[最小生成树算法之Kruskal]]
- 题目4: [[最小生成树算法之Prim]]
- 题目5: [[Dijkstra算法]]


