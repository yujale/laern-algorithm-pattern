# 预处理数组加速

---

- [[最少需要涂染几个正方形]]
- [[边框全是1的最大正方形的边长]]
- [[长方形中任意矩阵的累加和]]


- [[数组直方图装水]]  
   辅助数组 可以让复杂度 O(N)   
    需要0~i-1上的最大值  
    需要i+1~N-1的最大值  
    生成0~i-1上前缀数组的最大值数组  
    生成i+1~N-1上后缀数组的最大值数组  

- [[数组能不能分成4个相等的部分]]


- [[整数数组子数组累加和小于等于K的最大长度]]   
   预处理数组: minSum[i], minSumEnd[i]
   
   

- [[最长递增子序列问题的O(NxlogN)的解法]]  
构造ens数组, 引入ends数组, 加速  
跟原来array等长    
ends\[i\]: 找到所有长度为i+1的递增子序列中, 最小结尾是什么值 
目标:  
怎么样找到一种特别好的加速方式, 最终能够让定位每一次dp值出来的复杂度是logN    
策略:  
任何一个当前的数cur, 去有效去找>=cur最左的位置, 把它填进去, 然后看看这个位置  
左边包括自己有几个数, 就是它的dp值, 如果找的过程中, 没有>=你的数, 扩充有效区  
一直到把所有dp都生成  
流程为什么对?  
因为ends数组, 每一步, 每一个有效区里面每一个位置的值, 含义都能维持的住


[[分糖果问题]]
> left, right 相同位置求最大值  
 当前数比左侧数大, +1, 当前数不比左侧数大, 回到1  
left相当于 左坡  
right相当于 右坡
用辅助数组做简单, 不用辅助数组很难



## 前缀异或和数组
- [[最大子数组异或和]] : 暴力解法中使用, 最优解是前缀树做法  
>如果不优化  
假设是i结尾  
0..i所有数异或  
1..i所有数异或  
2..i所有数异或  
...  
假设变量a记录了0..i的异或和  
1...i的异或和就是  a ^ \[0...0\]的异或和  
2...i的异或和就是 a ^ \[0...1\]的异或和  
3...i的异或和就是 a ^ \[0...2\]的异或和  
这样用前缀异或和数组, 将算法复杂度减了一阶, 到N^2

