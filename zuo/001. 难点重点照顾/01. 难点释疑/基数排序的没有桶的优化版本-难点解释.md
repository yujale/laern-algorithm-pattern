# 基数排序的没有桶的优化版本-难点解释

---

### 初始状态, 生成Count, 前缀和Count\`, 以及help数组

![[Pasted image 20201207223959.png]]


### 从左往右遍历数组, 先看第一个数字040:

![[Pasted image 20201207230538.png]]

Count\`数组中, 0位置的1被使用过了, 自减1, 变为0


### 倒数第二个数031
![[Pasted image 20201207230829.png]]
Count\`数组中, 1位置的4被使用过了, 自减1, 变为3

### 倒数第三个数022

![[Pasted image 20201207231207.png]]

Count\`数组中, 2位置的5被使用过了, 自减1, 变为4

### 倒数第四个数001

![[Pasted image 20201207231602.png]]
Count\`数组中, 1位置的3被使用过了, 自减1, 变为2


### 倒数第五个数101

![[Pasted image 20201207233326.png]]

Count\`数组中, 1位置的2被使用过了, 自减1, 变为1


用这种方式没有桶, 优雅的实现了出桶入桶

只更新当前数字的count\`数组, 因为我只关心我当前数字的出现范围, 当填过以后, 当前数字的范围就会缩小


## 难点
数组中的数, 如果入桶, 越在后面的数, 越在桶的后面, 出桶最晚, 拍的位置比同一个桶内前面的数靠后

![[Pasted image 20201207232747.png]]

遍历数组, 从右往左, 则 当前数就是桶内最后一个数, 应该放在count\`数组确定的数组范围的最后/右一个

### 从右往左填数的顺序解释

![[Pasted image 20201208004207.png]]

Count\`数组中, 1位置的4被使用过了, 自减1, 变为3
![[Pasted image 20201208004216.png]]


为什么从右往左遍历==>
因为思路就是 每一个个位数出现的数字就是从右往左填写

### 如果从左往右填写呢?
当然, 也可以从左往右遍历, ==需要就算>=1的数有几个==, 就可以推出一个范围 i ~N-1, 顺着填写, Count\`前缀和数组倒着生成即可

![[Pasted image 20201208004753.png]]




