# 距离首都距离

---

给定一个长度为N的非负数组father，father里面所有的值为0~N-1
father[i] == j表示i城市的父亲是j城市，这个图无环
如果发现father[a] == a，说明a是首都，这个图不是森林是多叉树
根据father可以还原出图来，图中每个城市到首都的距离为边数
请把father原地更新成距离数组，更新完成后father[s] = t表示：
到首都距离为s的城市数量为t

---

给定一个路径数组 paths，表示一张图。paths[i]==j 代表城市 i 连向城市 j，如果 paths[i]==i， 则表示 i 城市是首都，一张图里只会有一个首都且图中除首都指向自己之 外不会有环。
例如， paths=[9,1,4,9,0,4,8,9,0,1]，
![[Pasted image 18.png]]
由数组表示的图可以知道，城市 1 是首都，所以距离为 0，离首都距离为 1 的城市只有城 市 9，离首都距离为 2 的城市有城市 0、3 和 7，离首都距离为 3 的城市有城市 4 和 8， 离首都 距离为 4 的城市有城市 2、5 和 6。所以距离为 0 的城市有 1 座，距离为 1 的 城市有 1 座，距离 为 2 的城市有 3 座，距离为 3 的城市有 2 座，距离为 4 的城市有
3 座。那么统计数组为nums=[1,1,3,2,3,0,0,0,0,0]，nums[i]==j 代表距离为 i 的城市有 j 座。要求实现一个 void 类型的函 数，输入一个路径数组 paths，直接在原数组上调整， 使之变为 nums 数组，即 paths=[9,1,4,9,0,4,8,9,0,1]经过这个函数处理后变成 [1,1,3,2,3,0,0,0,0,0]。
【要求】
如果 paths 长度为 N，请达到时间复杂度为 O(N)，额外空间复杂度为 O(1)。

