# 合并相邻K个数字的最小代价 



---
给定一个数组arr，和一个整数k。
这代表你可以把相邻的k个数字合成一个数字，每一次合并的代价是这些数字的累加和。
最终你的目标是把arr中所有数字合成一个，返回最小代价。

Input: stones = [3,2,4,1], K = 2
Output: 20
解释: 
一开始是[3, 2, 4, 1]，只能相邻的2个数字合成一个数字。
先合并[3, 2]变成5，代价是5。 那么就得到了[5, 4, 1]。
先合并[4, 1]变成5，代价是5。 那么就得到了[5, 5]。
先合并[5, 5]变成10，代价是10。 那么就得到了一个数字10。
总代价是20，而且这种方案是最省的。

Input: stones = [3,2,4,1], K = 3
Output: -1
解释：
只能相邻的3个数字合成一个数字，那么合并一次，数字就不够了。所以返回-1。

Input: stones = [3,5,1,2,6], K = 3
Output: 25
解释
开始是[3, 5, 1, 2, 6]，只能相邻的3个数字合成一个数字。
先合并[5, 1, 2]变成8，代价是8, 就变成了[3, 8, 6]
再合并[3, 8, 6]变成17，代价17，就变成了[17]
总代价是25，而且是所有方案中最小的。
