# 二维数组最大递增链的长度

329.矩阵中的最长递增路径

[M]

---
给定一个二维数组matrix，可以从任何位置出发，每一步可以走向上、下、左、右，四个方向。返回最大递增链的长度。  
例子：  
matrix =   
5  4  3  
3  1  2  
2  1  3  
从最中心的1出发，是可以走出1 2 3 4 5的链的，而且这是最长的递增链。所以返回长度5

ref: 329.[[矩阵中的最长递增路径]] [M]

---

如果能做出一张精确的位置依赖动态规划表  
 每个格子从左往右, 从上往下,或者自己规定一个非常严格的顺序  
从简单状态推到复杂状态==>经典动态规划的样子

本题: a位置依赖上下左右 abcd位置,  要先求abcd的值吗? 不行, 因为b位置有可能反过来依赖a  
 , 既然如此, 位置依赖顺序比较混乱, 就不把它做成严格位置依赖动态规划, 直接改成从顶到底的动态规划就结束了, 本质上没有区别  
  
如果位置依赖是非常精确的,改起来比较容易就去改, 如果感觉位置依赖不是很明确,那就不改,记忆化  
搜索的办法就可以了  
怎么知道改到记忆化搜索就可以,不会有更好的方法?  
你在推具体一个状态时,如果它就是有限几个位置依赖, 你改不改, 时间复杂度都不会有变化  
 严格位置依赖有限几个位置, 记忆化搜索也是依赖有限几个位置 它俩其实是等效的  
迫切需要改成严格位置依赖的情况:  
 比如某道题, 位置依赖有多个, 而且有枚举行为, 这时候最好改, 因为改成严格位置依赖以后, 可以继续优化, 把这个枚举行为  
 已经知道严格位置依赖,就可以得到它的状态转移方程, 在转移方程看看,这种遍历的枚举行为是不是能够被临近位置的一些值代替
 
 位置依赖比较乱, 就不弄严格位置依赖的DP了, 本质没有区别, 记忆化搜索已经不错了
 
 严格位置依赖的DP可以改
 枚举行为是否可以被临近可以优化
 
 工作中避免递归-->改成迭代  
用递归方法在系统上准备一个函数, 它虽然是常数时间, 但是这个常数时间是比较大的,  
  
能改成迭代就别写递归, 但是做算法题无所谓, 算法题不会卡常数时间  
  
但在工作中遇到一个算法问题, 一定要杜绝代码中有递归, 要把所有递归改成迭代版本.