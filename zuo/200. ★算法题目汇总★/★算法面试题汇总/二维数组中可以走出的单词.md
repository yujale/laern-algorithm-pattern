# 二维数组中可以走出的单词



---

给定一个char[][] matrix，也就是char类型的二维数组，再给定一个字符串word，
可以从任何一个某个位置出发，可以走上下左右，能不能找到word？     
 char[][] m = {  { 'a', 'b', 'z' },   
                       { 'c', 'd', 'o' },   
                       { 'f', 'e', 'o' },    
设定1：可以走重复路的情况下，返回能不能找到  
比如，word = "zoooz"，是可以找到的，z -> o -> o -> o -> z，因为允许走一条路径中已经走过的字符  
设定2：不可以走重复路的情况下，返回能不能找到  
比如，word = "zoooz"，是不可以找到的，因为允许走一条路径中已经走过的字符不能重复走   

---

Plus: 

给定一个字符类型的二维数组board，和一个字符串组成的列表words。
可以从board任何位置出发，每一步可以走向上、下、左、右，四个方向，
但是一条路径已经走过的位置，不能重复走。   
返回words哪些单词可以被走出来。   
例子   
board = [   
  ['o','a','a','n'],   
  ['e','t','a','e'],   
  ['i','h','k','r'],   
  ['i','f','l','v']   
]   
words = ["oath","pea","eat","rain"]   
输出：["eat","oath"]   

---


技巧来自于: 递归过程中 把剪枝玩的特别好, 你能够想出多少剪枝条件,就是练习这个能力  
  
建立各种机制去剪枝, 能做到多深, 忽略任何一点, 再过测试用例的时候, 都有可能时间卡不过,   
  
故意设计出来, 卡常数时间的题, 不剪枝,增加了常数时间, 剪枝, 让程序迅速跑完.

